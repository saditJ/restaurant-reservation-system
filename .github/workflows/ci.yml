name: CI

on:
  push:
    branches:
      - main
  pull_request:

env:
  PNPM_VERSION: '9.15.9'
  NODE_VERSION: '22.18.0'
  DATABASE_URL: postgresql://reserve:reserve@localhost:5432/reserve?schema=public
  REDIS_URL: redis://localhost:6379/0
  PII_SECRET: ci-pii-secret
  PII_KEY_VERSION: v1
  API_KEY: dev-local-key
  API_KEYS: dev-local-key
  SWAGGER_API_KEY: ci-swagger-key
  API_BASE_INTERNAL: http://localhost:3003
  NEXT_PUBLIC_API_BASE: /api
  WAITLIST_ENABLED: 'false'
  NEXT_PUBLIC_WAITLIST_ENABLED: 'false'
  NEXT_PUBLIC_VENUE_TZ: UTC
  LOG_LEVEL: warn
  PORT: '3003'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Ensure pnpm binary exists first
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies (include dev deps, create node_modules layout)
        env:
          NODE_ENV: development
        run: |
          pnpm -v
          node -v
          # Use shamefully-hoist so package-level bin links are available where per-package scripts expect them
          pnpm install --frozen-lockfile --shamefully-hoist

      - name: Verify install (debug)
        run: |
          echo "node: $(node -v) pnpm: $(pnpm -v)"
          pnpm config get node-linker || true
          pnpm -w list --depth 0 || true
          echo "root node_modules/.bin:"
          ls -la node_modules/.bin || true
          for p in apps/api apps/market apps/provider apps/b2b-console apps/booking-widget; do
            echo ">>> $p node_modules/.bin"
            ls -la $p/node_modules/.bin || true
          done

      - name: Rebuild workspace links
        run: pnpm -w rebuild || true

      - name: Lint
        # Run recursive workspace lint from root (bins should now be available thanks to --shamefully-hoist)
        run: pnpm -w -r --if-present lint

      - name: Typecheck
        run: pnpm typecheck

      - name: Unit tests
        run: pnpm test

      - name: Prisma validate
        run: pnpm prisma:validate

      - name: Build packages
        run: pnpm build

      - name: Generate OpenAPI spec
        run: pnpm --filter api openapi:generate

      - name: Upload OpenAPI spec
        uses: actions/upload-artifact@v4
        with:
          name: openapi-json
          path: apps/api/openapi.json
          if-no-files-found: error

  db:
    needs: build
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: reserve
          POSTGRES_PASSWORD: reserve
          POSTGRES_DB: reserve
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U reserve"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=5s
          --health-timeout=3s
          --health-retries=10
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies (include dev deps)
        env:
          NODE_ENV: development
        run: pnpm -w install --frozen-lockfile --include=dev --shamefully-hoist

      - name: Verify install (debug)
        run: |
          node -v
          pnpm -v
          pnpm -w list --depth 0 || true
          ls -la node_modules/.bin || true
          ls -la apps/provider/node_modules/.bin || true

      - name: Rebuild workspace links
        run: pnpm -w rebuild || true

      - name: Wait for Postgres and Redis
        run: pnpm exec tsx scripts/ci/wait-for-services.ts

      - name: Validate Prisma schema
        run: pnpm prisma:validate

      - name: Deploy migrations
        run: pnpm db:migrate:deploy

  migrate_seed:
    needs: db
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: reserve
          POSTGRES_PASSWORD: reserve
          POSTGRES_DB: reserve
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U reserve"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=5s
          --health-timeout=3s
          --health-retries=10
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies (include dev deps)
        env:
          NODE_ENV: development
        run: pnpm -w install --frozen-lockfile --include=dev --shamefully-hoist

      - name: Verify install (debug)
        run: |
          node -v
          pnpm -v
          pnpm -w list --depth 0 || true
          ls -la node_modules/.bin || true
          ls -la apps/provider/node_modules/.bin || true

      - name: Rebuild workspace links
        run: pnpm -w rebuild || true

      - name: Wait for Postgres and Redis
        run: pnpm exec tsx scripts/ci/wait-for-services.ts

      - name: Deploy migrations
        run: pnpm db:migrate:deploy

      - name: Seed database
        run: pnpm db:seed

      - name: Database smoke check
        run: pnpm db:check

  api:
    needs: migrate_seed
    runs-on: ubuntu-latest
    env:
      CI_API_BASE: http://127.0.0.1:3003
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: reserve
          POSTGRES_PASSWORD: reserve
          POSTGRES_DB: reserve
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U reserve"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=5s
          --health-timeout=3s
          --health-retries=10
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies (include dev deps)
        env:
          NODE_ENV: development
        run: pnpm -w install --frozen-lockfile --include=dev --shamefully-hoist

      - name: Verify install (debug)
        run: |
          node -v
          pnpm -v
          pnpm -w list --depth 0 || true
          ls -la node_modules/.bin || true
          ls -la apps/provider/node_modules/.bin || true

      - name: Rebuild workspace links
        run: pnpm -w rebuild || true

      - name: Wait for Postgres and Redis
        run: pnpm exec tsx scripts/ci/wait-for-services.ts

      - name: Apply migrations
        run: pnpm db:migrate:deploy

      - name: Seed database
        run: pnpm db:seed

      - name: Build API
        run: pnpm --filter api build

      - name: Start API
        run: |
          pnpm --filter api start:prod > api.log 2>&1 &
          echo $! > api.pid

      - name: Wait for API readiness
        run: |
          for attempt in {1..30}; do
            if curl -fsS http://127.0.0.1:3003/ready >/dev/null; then
              curl -fsS http://127.0.0.1:3003/health
              exit 0
            fi
            sleep 4
          done
          echo "API did not become ready" >&2
          exit 1

      - name: Stop API
        if: always()
        run: |
          if [ -f api.pid ]; then
            PID=$(cat api.pid)
            if kill -0 "$PID" 2>/dev/null; then
              kill "$PID" || true
              wait "$PID" || true
            fi
          fi
          rm -f api.pid

      - name: Upload API logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: api-logs
          path: api.log
          if-no-files-found: warn

  smoke:
    needs: api
    runs-on: ubuntu-latest
    env:
      CI_API_BASE: http://127.0.0.1:3003
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: reserve
          POSTGRES_PASSWORD: reserve
          POSTGRES_DB: reserve
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U reserve"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=5s
          --health-timeout=3s
          --health-retries=10
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies (include dev deps)
        env:
          NODE_ENV: development
        run: pnpm -w install --frozen-lockfile --include=dev --shamefully-hoist

      - name: Verify install (debug)
        run: |
          node -v
          pnpm -v
          pnpm -w list --depth 0 || true
          ls -la node_modules/.bin || true
          ls -la apps/provider/node_modules/.bin || true

      - name: Rebuild workspace links
        run: pnpm -w rebuild || true

      - uses: grafana/setup-k6-action@v1
        with:
          version: v0.49.0

      - name: Wait for Postgres and Redis
        run: pnpm exec tsx scripts/ci/wait-for-services.ts

      - name: Apply migrations
        run: pnpm db:migrate:deploy

      - name: Seed database
        run: pnpm db:seed

      - name: Build API
        run: pnpm --filter api build

      - name: Start API
        run: |
          pnpm --filter api start:prod > api-smoke.log 2>&1 &
          echo $! > api.pid

      - name: Wait for API readiness
        run: |
          for attempt in {1..30}; do
            if curl -fsS http://127.0.0.1:3003/ready >/dev/null; then
              exit 0
            fi
            sleep 4
          done
          echo "API did not become ready for smoke tests" >&2
          exit 1

      - name: Run smoke checks
        run: pnpm exec tsx scripts/ci/smoke.ts

      - name: Run k6 availability smoke
        run: |
          mkdir -p artifacts
          k6 run scripts/k6/availability.js \
            --summary-export=artifacts/k6-summary.json \
            --vus 1 \
            --duration 10s
        env:
          BASE_URL: http://127.0.0.1:3003/v1
          API_KEY: ${{ env.API_KEY }}
          VENUE_ID: venue-brooklyn
          DATE: 2025-12-24
          TIME: 19:00
          PARTY: '2'

      - name: Summarize k6 results
        if: always()
        run: |
          if [ -f artifacts/k6-summary.json ]; then
            pnpm exec tsx scripts/ci/k6-summary.ts artifacts/k6-summary.json artifacts/k6-summary.txt
          fi

      - name: Stop API
        if: always()
        run: |
          if [ -f api.pid ]; then
            PID=$(cat api.pid)
            if kill -0 "$PID" 2>/dev/null; then
              kill "$PID" || true
              wait "$PID" || true
            fi
          fi
          rm -f api.pid

      - name: Upload API logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: api-logs-smoke
          path: api-smoke.log
          if-no-files-found: warn

      - name: Upload smoke artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-artifacts
          path: |
            artifacts/k6-summary.json
            artifacts/k6-summary.txt
          if-no-files-found: warn

  preview:
    needs: smoke
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: postgresql://reserve:reserve@127.0.0.1:5432/reserve?schema=public
      REDIS_URL: redis://127.0.0.1:6379/0
      PREVIEW_TTL_SECONDS: '300'
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies (include dev deps)
        env:
          NODE_ENV: development
        run: pnpm -w install --frozen-lockfile --include=dev --shamefully-hoist

      - name: Verify install (debug)
        run: |
          node -v
          pnpm -v
          pnpm -w list --depth 0 || true
          ls -la node_modules/.bin || true
          ls -la apps/provider/node_modules/.bin || true

      - name: Rebuild workspace links
        run: pnpm -w rebuild || true

      - name: Start database dependencies
        run: docker compose up -d postgres redis

      - name: Wait for Postgres and Redis
        run: pnpm exec tsx scripts/ci/wait-for-services.ts

      - name: Apply migrations
        run: pnpm db:migrate:deploy

      - name: Seed database
        run: pnpm db:seed

      - name: Create preview API key
        id: preview_key
        run: |
          result=$(pnpm exec tsx scripts/ci/create-preview-key.ts --name "Preview PR #${{ github.event.pull_request.number }}")
          key=$(echo "$result" | jq -r '.plaintext')
          id=$(echo "$result" | jq -r '.id')
          echo "::add-mask::$key"
          echo "plaintext=$key" >> "$GITHUB_OUTPUT"
          echo "key_id=$id" >> "$GITHUB_OUTPUT"
          echo "Preview API key created: $id"

      - name: Export preview secrets
        run: |
          echo "PREVIEW_ADMIN_KEY=${{ steps.preview_key.outputs.plaintext }}" >> "$GITHUB_ENV"
          echo "SWAGGER_API_KEY=${{ steps.preview_key.outputs.plaintext }}" >> "$GITHUB_ENV"
          echo "API_KEY=${{ steps.preview_key.outputs.plaintext }}" >> "$GITHUB_ENV"

      - name: Start preview API
        run: docker compose --profile preview up -d api

      - name: Wait for preview API readiness
        run: |
          for attempt in {1..30}; do
            if curl -fsS http://localhost:3003/ready >/dev/null; then
              exit 0
            fi
            sleep 5
          done
          echo "Preview API did not become ready" >&2
          docker compose logs api || true
          exit 1

      - name: Install cloudflared
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared

      - name: Start tunnel
        id: tunnel
        run: |
          ./cloudflared tunnel --url http://localhost:3003 --no-autoupdate > tunnel.log 2>&1 &
          echo $! > cloudflared.pid
          for attempt in {1..30}; do
            if grep -q "trycloudflare.com" tunnel.log; then
              url=$(grep -oE "https://[a-zA-Z0-9.-]+trycloudflare.com" tunnel.log | head -n 1)
              if [ -n "$url" ]; then
                echo "url=$url" >> "$GITHUB_OUTPUT"
                echo "TUNNEL_URL=$url" >> "$GITHUB_ENV"
                break
              fi
            fi
            sleep 2
          done
          if [ -z "${TUNNEL_URL:-}" ]; then
            echo "Failed to extract tunnel URL"
            cat tunnel.log
            exit 1
          fi

      - name: Post preview comment
        uses: actions/github-script@v7
        with:
          script: |
            const body = [
              '### Preview Environment',
              `• API ready: ${process.env.TUNNEL_URL}/ready`,
              `• Swagger UI: ${process.env.TUNNEL_URL}/docs (use x-api-key)`,
              `• Admin key: \`${process.env.PREVIEW_ADMIN_KEY}\``,
              '',
              '_Preview will be torn down after this workflow completes._',
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
        env:
          TUNNEL_URL: ${{ env.TUNNEL_URL }}
          PREVIEW_ADMIN_KEY: ${{ steps.preview_key.outputs.plaintext }}

      - name: Keep preview alive
        run: |
          echo "Preview environment available at ${TUNNEL_URL} for ${PREVIEW_TTL_SECONDS}s"
          sleep "${PREVIEW_TTL_SECONDS}"

      - name: Stop tunnel
        if: always()
        run: |
          if [ -f cloudflared.pid ]; then
            PID=$(cat cloudflared.pid)
            if kill -0 "$PID" 2>/dev/null; then
              kill "$PID" || true
              wait "$PID" || true
            fi
          fi
          rm -f cloudflared.pid

      - name: Teardown preview stack
        if: always()
        run: docker compose down --volumes --remove-orphans
